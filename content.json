{"pages":[{"title":"","text":"/** * Keyboard styling */ kbd { background-color: #eee; border-radius: 3px; border: 1px solid #b4b4b4; box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset; color: #333; display: inline-block; font-size: .85em; font-weight: 700; line-height: 1; padding: 2px 4px; white-space: nowrap; }","link":"/assets/extra.css"}],"posts":[{"title":"New Blog Introduction","text":"Hello to whoever is reading this! After many years of learning benefiting from the online writing of others, I have finally decided to start my own blog. I do this both to give back to the community that helped me learn and grow as a software engineer, and to give myself a platform to share my thoughts and experiences. I do not know what the future holds for this platform. It could be filled with helpful articles on programming, as I originally planned. It could instead cover a broader range of topics, such as music or other things I find interesting. It also could very well not go anywhere because, being a fairly private person, I‚Äôm not eager to have a large presence online. I suppose you‚Äôll just have to wait and see! For now, you can check out my main website: https://tannernielsen.com","link":"/2019/01/20/New-Blog-Introduction/"},{"title":"Using the NPM API to Get Latest Package Versions","text":"The official npm API provides a simple way to programmatically retrieve the latest version of any package, along with other metadata you might find in the package.json. This has a variety of use cases, such as checking when a package is out of date, to name one example. Today I‚Äôll demonstrate how to get the latest version of a package with only a few lines of code. However, I was frustrated with what I found in other solutions, so I also want to talk about those and why you shouldn‚Äôt use them. A very popular way to get the latest version is through the latest-version package on npm, which has nearly 3 million weekly downloads. The package sports a shiny badge (so you know it‚Äôs good), and the README even tells you why you should choose this package over the latest package, which has ‚Äúmassive‚Äù dependencies. The code example also looks pretty slick: 12console.log(await latestVersion('ava'));//=&gt; '0.18.0' So my first impression is that the package is popular, reliable, more lightweight than the competition, and simple to use. Sounds great to me! Let‚Äôs just check the download size before installing‚Ä¶ Wait a minute‚Ä¶ This package literally exposes one function that does one thing. How on earth could it possibly require nearly 90kB, minified?! It turns out that the culprit is the package‚Äôs only (and much more useful) dependency, package-json, which allows you to extract information from any package.json file on npm. The crime here (in my opinion) is that this dependency is over-qualified; it feels a lot like cracking an egg with a hammer. Moreover, the hammer itself is overkill, as the npm API already provides this information. We can do better: A Better SolutionUsing the npm API and the much lighter-weight dependency, axios, we can rewrite the entire latest-version module in a handful of lines: 12345function latestVersion(packageName) &#123; return axios .get('https://registry.npmjs.org/' + packageName + '/latest') .then(res =&gt; res.data.version);&#125; Just like the original package, latestVersion() returns a promise, so you can use it exactly the same as the latest-version docs describe: 1const packageVersion = await latestVersion('some-package'); ConclusionI hope this saved you some unnecessary code bloat. If you want to see how other packages will affect your bundle size in the future, you can check for yourself at bundlephobia.com.","link":"/2019/02/18/Using-the-NPM-API-to-Get-Latest-Package-Versions/"},{"title":"Creating an Engraved Leather Effect with CSS","text":"I love the look of gold-engraved leather. You see it all the time on portfolios, diplomas, etc., and I think the reason is because it really does have a universal appeal. However, you don‚Äôt see it so often on the web. Perhaps it just doesn‚Äôt fit with the flat style that dominates the internet. Or maybe (most likely) it‚Äôs because the effect cannot easily be pulled off in CSS. Traditionally, if you wanted to include something like the above image on your website, you‚Äôd be forced to create it with Photoshop or other external software, then include the image in the HMTL. If you ever want to change the text, resize or change the font, you would have to create it all again. Additionally, you probably need to keep track of multiple sizes and layouts for different display sizes‚Ä¶ Not worth the hassle unless you really need the effect. So what can a poor developer do? Luckily, with a few CSS tricks and clever texturing, there is in fact a way to mimic this lovely style yourself, without sacrificing flexibility! And: It works with any text (even emojis to an extent üò≤) It work with any font (including Font Awesome, or a similar font-based icon system ) Both the text and font can change on the fly without messing up the effect Today, I will walk you through my process so you can create the effect on your own, and I‚Äôll even give away the special Blender-made textures at the end of the article. It‚Äôs a bumpy road ahead, but hopefully you find something useful along the way. Breaking it down: How does it work?Before we can get to work, we need to briefly break down how the effect is pulled off. There are several key pieces to note: Normal mapping on the gold texture (the one part that must be pre-made) makes it look as though the gold is ‚Äúpainted‚Äù directly on the leather. Without this effect, the gold just looks wrong. background-clip: text allows us to clip the gold texture to the shape of the text. Multiple text-shadows create the illusion that the text has been pressed into the leather. I will walk through these effects in the above order, starting with the normal mapping, which is by far the trickiest. If you don't know what a normal map is, a YouTube search can probably answer most of your questions. All you really need to know is that they help 3D software render lighting for geometrically complex surfaces. Step 1 - Creating the TexturesOur first goal is to create leather and gold textures that looks a bit like this: We will not be creating the actual letters in this step, but notice how the gold is clearly ‚Äúpainted‚Äù on to the existing bumps and crevices. We will be using Blender achieve this effect. If you do not want to go through the hassle of creating your own textures, you can skip sections 1.1 - 1.7, as I will be giving away my textures at the end of the article. However, if you wanted to go for a slightly different effect, such black text on brown leather, or even red paint on concrete, these steps will be very helpful for you. Step 1.1 - Get BlenderFirst, you‚Äôll want to be sure you have Blender installed AND that you have version 2.79b or later. This version has new features that we‚Äôll need. Step 1.2 - Find your TexturesNext, you need to find a seamless leather texture along with its matching normal map (and optional specular map). A number of sites provide high-quality textures; Poliigon perhaps is the best and most popular, but it‚Äôs not free for all textures. Texturize is another site that provides all textures royalty-free, but the selection is smaller. Luckily, it had the kind of leather I was looking for. Go ahead and download the diffuse and normal texture. You can also download the specular texture if you wish. If you have your own texture and need a normal map for it, there are a number of tools that can generate one for you, some online and some for desktop use. However, you'll want to know what you're doing for these and they're outside the scope of this tutorial. Step 1.3 - Setup the GeometryNow we can open Blender and start preparing our textures. This article will assume basic knowledge of Blender, but I will make an effort to be very clear about what I‚Äôm doing. After starting Blender, the first thing we want to do is select everything in the scene (a) and delete it (delete , enter). Next, let‚Äôs create (shift + a) a new Mesh &gt; Plane and scale (s) it by 5. If you accidentally moved the 3D cursor and the plane is off center, you can hit n to bring up the properties panel and reset the position to 0. You should have something like this: Next, let‚Äôs add a simple directional light to the scene. In the main view, add (shift + a) a new Lamp &gt; Sun. Pull up the properties panel (n) once more and set the position of the lamp to (0, 0, 10), just to get it out of the way, and set the rotation to (-20, -20, 0). You don‚Äôt need to worry about where the line from the light hits the plane, because the light is only directional. Step 1.4 - Setup the Leather MaterialNow we need to create and setup a material for our plane that will utilize the leather texture we downloaded earlier. But before we mess with any materials, we want to make sure Blender is set to ‚ÄúCycles Render‚Äù rather than ‚ÄúBlender Render‚Äù (top of the screen). If you need any help with the following steps, refer to this excellent video, which is where I got most of my information. It's a bit long, so I would only refer to it if you run into issues. Then, collapse the left-hand panel (t) to make more room, then split the main view by clicking and dragging to the left from the upper right-hand corner: Before we can apply our leather textures, we need to UV-unwrap our plane. This simply allows our textures to be mapped to the 3D geometry, which in our case is just a simple plane. First, in the new right-hand view, change the type to ‚ÄúUV/Image Editor‚Äù in the bottom left. The view should be blank at the moment. Then, in the left-hand 3D view, select the plane (right-click) and hit tab to enter edit mode. Then hit u and select ‚ÄúUnwrap‚Äù to UV-unwrap our plane. If all works properly, you should see the UV coordinates in the UV/Image Editor now: Hit tab once more to exit edit mode, then change the right-hand editor to ‚ÄúNode Editor,‚Äù and hit n to close the properties panel. This view is where we will edit our leather and gold materials, so click the big ‚ÄúNew‚Äù button to create a material. This will give us a default white diffuse material. To preview how this will look rendered, hover the mouse over the left-hand 3D view and press shift + z (which can also be used to flip back to the default 3D view): Not much to see at the moment. Let‚Äôs select the ‚ÄúDiffuse BSDF‚Äù shader (right-click) and delete it. We‚Äôll need a more complex shader for our material: Hit shift + a and add a Shader &gt; Principled BDSF node. Do not be intimidated by all the options! Just start by connecting the green BDSF output to the Surface input on the Material Output node. Once you do that, the rendered view should look the same as it did with the default diffuse shader. Now we need to add (shift + a) a Texture &gt; Image Texture node. Click the Open button and find the leather texture you downloaded (the one that looks like normal leather). After that, you can connect the color output on the image texture to the input on the Principled BDSF, and you will see the leather texture in the rendered view: This does look like the leather, but you can see that it doesn‚Äôt quite look right ‚Äì the light isn‚Äôt interacting with the bumps of the leather. Of course, that shouldn‚Äôt be too surprising, because we simply told Blender to slap an image on a flat plane; it doesn‚Äôt know what the bumps look like. This is where normal maps come in: Let‚Äôs add (shift + a) another Texture &gt; Image Texture node, and open the normal map (the blue/purplish image) that accompanies the leather texture. Even though the normal map is technically an image, it‚Äôs not meant to be displayed as such, so change the ‚ÄúColor‚Äù drop down to ‚ÄúNon-Color Data.‚Äù We want to pipe this texture into the purple Normal input at the bottom of the Principled BSDF shader, but we must convert the color input to normal data beforehand. So let‚Äôs create another node (shift + a) and select Vector &gt; Normal Map. Finally, connect the color output of the image texture to the normal map, and send the normal map output to the Normal input on the Principled BSDF shader. After all of that, you should be able to see that the leather now has some texture: If you have a specular map as well, you can add (shift + a) another Texture &gt; Image Texture, open the specular map file, set it to ‚ÄúNon-Color Data‚Äù, and connect the output into the Specular input on the Principled BSDF shader. The effects of this are more subtle and not strictly necessary. You can also tinker with the roughness slider to achieve similar effects. For me, I had to turn up the roughness to make the leather not look so plastic-like. You may also want to turn up/down the strength of the sun lamp. It‚Äôs all a matter of preference. Once you‚Äôre satisfied, you can rotate the camera (middle-mouse-button drag) to see what the plane looks like from above, as we‚Äôll see it in the HTML: Step 1.5 - Bake the Composite Leather TextureNow that we have a model of what our leather should look like in 3D space with 3D lighting, we can ‚Äúbake‚Äù the result to another texture that we can use in HTML. If you need any help with the following steps, refer to this video, which covers the basics of Cycles baking. Again, it's long, so I would only refer to it if you run into issues. Let‚Äôs start by switching our left-hand view to ‚ÄúUV/Image Editor.‚Äù Then click the big ‚ÄúNew‚Äù button at the bottom to create a new image for our texture to be baked onto. Make sure the image is the same dimensions as the original textures, and uncheck alpha, because we won‚Äôt need it: Next turn your attention to the far right-hand side of the screen, where there are a bunch of options pertaining to rendering. Scroll down and find the ‚ÄúSampling‚Äù section. Within, there are two numbers for samples: one for render and the other for preview. The ‚ÄúRender‚Äù one is relevant to rendering and baking, so this number concerns us. This is effectively the quality of our render, so crank that up to 250 or so. The higher you go, the longer it will take. Keep scrolling to the bottom and expand the ‚ÄúBake‚Äù section, which has a big ‚ÄúBake‚Äù button. This will launch the baking process, but first we need to let Blender know where to bake the texture to. In the node editor, shift + a to create another Texture &gt; Image Texture. This node will not be connected to anything; it will only serve to tell Blender where to bake our texture. On the image texture node, select the blank image we created just a moment ago (don‚Äôt open a file). Finally, with the orphan image texture node selected (it must be selected or you will overwrite one of your original textures), you can hit the big ‚ÄúBake‚Äù button. This process may take a few minutes: After that‚Äôs complete, you should see the rendered result in UV/Image Editor view. To save the image, click ‚ÄúImage‚Äù at the bottom and select ‚ÄúSave as Image‚Äù. You should now have an image file that looks something like this: Step 1.6 - Setup the Gold MaterialNow we need to create a gold material that has the same normal mapping as the leather, which will make it look as though the gold has been painted on top of the leather. Luckily, we can leverage the work we just did so we don‚Äôt have to do it all again. First, change the left-hand view back to 3D view and turn on live rendering (shift + z) so we can see the material as it changes. Next, we need to find a gold texture somewhere online, and preferably a seamless one. Unlike the leather, we won‚Äôt need any normal maps or specular maps, because we will just be using the ones from the leather. Metallic textures can be tricky because we don‚Äôt want a texture that already has the reflections built in; Blender will calculate the reflections based on the leather normals. Try to find a relatively flat texture, perhaps like this one: Now let‚Äôs load the gold texture into blender. First, we need to duplicate the leather texture since the gold texture will be very similar. Over on the right-hand side of the screen, go to the Material tab, and click the plus button to create a new material, and the node setup from the old material will automatically be copied. Now back up on the image texture node that‚Äôs plugged into the base color, swap out the leather image with the gold one you just downloaded. If all goes well, you should see something like this: Now we begin a game of tweaking: First, slide the ‚ÄúMetallic‚Äù slider on the Principled BSDF shader all the way up. (It is metal, after all!) You can also make it look more metallic by decreasing the roughness (0.4 looked good in my particular case). Things are looking a little dark a little dark for me, so let‚Äôs crank up the sun a bit. To do this, select the sun lamp in the scene hierarchy on the right-hand side, select the data tab, then scroll down and click the ‚ÄúUse Nodes‚Äù button. After doing so, you will have a strength parameter that you can now increase. There‚Äôs no magic number; just make it as bright as you‚Äôd like. Unfortunately, there are several parameters without magic numbers: the sun strength, the roughness, and the normal map strength, which can be found on the Normal Map node in the node editor. I went through several iterations to get things right, but in general, you will probably want a low normal strength (because the painted gold would ‚Äúsmooth‚Äù the crevices slightly) and you don‚Äôt want the gold to be too bright (which is influenced by all three factors), or it will look odd in contrast to the leather. Trial and error is the only way: Even though the last iteration looks a little dull, it ended up looking the best when I used it for gold text, so keep that in mind when choosing your parameters. Step 1.7 - Render the Gold to a TextureOne complication we have to deal with now is that due to the nature of Cycles baking, reflections and such can‚Äôt be baked directly to textures, because the reflections depend on viewing angle. So instead of baking the gold texture, we will setup an overhead camera and use that to render the texture. Assuming you‚Äôre happy with the gold material, you can turn off live rendering (shift + z) and go back to one view: Next, (shift + a) and create a camera. Open the properties panel (n) and with the camera selected, set the position to (0, 0, 10), and the rotation to (0, 0, 0), so our camera points straight down at the plane. Now over on the right-hand side of the screen, click the camera tab, change the camera to orthographic, and set the orthographic scale to 10. (Since we are rendering to a texture, we don‚Äôt want perspective to skew anything.) Finally, to get the aspect ratio correct, head over to the Render tab and adjust the resolution to match the size of the leather texture we created earlier: If you want to get a rough idea of what the final render will look like, hit 0 on the numpad to snap the viewport to the camera‚Äôs perspective, and hit shift + z to preview the render. You may find that at this angle, you will have to re-adjust the gold material parameters from before. Be sure to adjust based on this view because this is the one that will be rendered! Once you are happy with how it looks, you can hit the big render button and go grab a coffee or something ‚Äì it will take awhile. Once it‚Äôs done, you can save the image to a file like we did with the leather texture (and don‚Äôt forget to save! Blender will not save the render if you close out). If all goes well, you should have a leather texture that looks a bit like this: Step 2 - Adding the Textures to HTMLNow we are finally done with Blender (thank goodness!), and we have two images: a leather image, and a gold image with texturing that matches the leather. Using these two images, we can make it look like the gold is painted on the leather. Let‚Äôs start with some basic markup:123&lt;div class=\"leather textured\"&gt; &lt;h1 class=\"gold textured\"&gt;Gold Engraving&lt;/h1&gt;&lt;/div&gt; That‚Äôs all the markup we‚Äôll need for now. Let‚Äôs take a look at the CSS, starting with the leather class:1234.leather &#123; background-image: url(leather-texture.png); padding: 1em;&#125; This simply sets the background to the leather texture we created and gives us a little extra padding. Easy so far. Now let‚Äôs look at the gold class:12345678.gold &#123; background-image: url(gold-texture.png); background-clip: text; -webkit-background-clip: text; color: transparent; font-size: 70pt;&#125; Here, we set the background-image to our gold texture, but we set the background-clip property to text (along with the -webkit prefixed version). This clips the background so it only displays in the bounds of the text. However, the text would cover it up by default, so we set color: transparent to hide the actual text. With that, we get something that looks like this: Not quite what we‚Äôre looking for‚Ä¶ The textures don‚Äôt line up with each other and the leather is much too big. So, let‚Äôs fill in the third class I alluded to in the markup:1234.textured &#123; background-position: fixed; background-size: 900px 900px;&#125; This simply ensures that both textures will be the same size and align with each other. It‚Äôs difficult to see since the gold texturing is so subtle, so here‚Äôs a version with an exaggerated gold texture so you can see that it really does line up: Step 3 - Pressing the Gold TextLastly, we need to add some special text shadows to give the illusion that the text has been ‚Äúpressed‚Äù into the leather and not just a gold sticker on top of the leather. The following picture illustrates how we can use shadow to create this illusion: Here we have a shape pressed into a surface with the light coming from the upper left, just like our textures. You will notice that the upper and left edges are darker because they are obstructed from the light source, and the bottom and right edges are brighter because they are angled more directly towards the light. Using two text shadows, we can do the same thing. It takes some tweaking, but something like this works fairly well:123.gold &#123; text-shadow: -3px -3px 5px rgba(0,0,0,.8), 1px 1px 2px rgba(255,255,255,.45);&#125; ‚Ä¶but according to the MDN docs for background-clip, several browsers won‚Äôt render text-shadows properly when background-clip: text is used on the same element. This can be a pain in the butt because the only way to get around this is to put the shadows on a separate element. One option to make this less cumbersome is to use the ::before and ::after pseudo elements, and have them read from a common attribute. It‚Äôs easier to understand in code, so let‚Äôs revise our markup: 123&lt;div class=\"leather textured\"&gt; &lt;h1 class=\"gold textured\" data-text=\"Gold Engraving\"&gt;&lt;/h1&gt;&lt;/div&gt; Notice that the text is now entirely within an attribute. This allows us to access the text via the attr() CSS function to automatically duplicate the text across our two pseudo elements (one for the gold, and one for the shadow). Now let‚Äôs revise the gold class. This gets a little hairy, so I will break down each part: 1234.gold &#123; position: relative; font-size: 70pt;&#125; The actual .gold element now just serves as an anchor for our ::before and ::after elements. Since there will be absolute positioning involved with the pseudo elements, we need to set position: relative here. The ::before element will serve as our shadow element, since it needs to sit behind the gold: 1234.gold::before &#123; content: attr(data-text); text-shadow: -3px -3px 5px rgba(0,0,0,.8), 1px 1px 2px rgba(255,255,255,.45);&#125; Here is where the magic attr() function comes into play. By loading the data-text value into the content property, we have effectively inserted the text into the element, as if it were &lt;h1&gt;Gold Engraving&lt;/h1&gt;. Since this element isn‚Äôt using background-clip: text, we are free to add our shadows here. The ::after element will serve as the gold text element: 12345678910111213.gold::after &#123; content: attr(data-text); position: absolute; left: 0; top: 0; background-position: inherit; background-size: inherit; background-image: url(gold-texture.png); background-clip: text; -webkit-background-clip: text; color: transparent;&#125; Here the background-image stuff is the same as before, only now we get our text content from attr(data-text), just like ::before. Then, to get the gold to sit directly on top of the shadow, we use absolute positioning. And that‚Äôs it! You can check out the results in this Fiddle: ConclusionThere you have it! Hopefully this article was insightful, and perhaps you can build upon these techniques to do other effects as well. As promised, here are the leather and gold textures for your convenience. Feel free to use them however you‚Äôd like. üòÉ","link":"/2019/01/25/2019-01-21-Creating-an-Engraved-Leather-Effect-with-CSS/"},{"title":"Budgeteer - A Budget-Balancing Tool","text":"You can gain some useful insights by visualizing your budget, but creating a chart like the one above this isn‚Äôt always worth the effort. That‚Äôs why I created a tool called Budgeteer that makes it easy make these charts without tedious work. In this post, I‚Äôd like to talk a little bit about how to use the tool as well as some of the math behind it. Click here if you just want to learn how to use the tool Click here if you‚Äôre interested in the underlying math MotivationBefore I continue I must give credit to Steve Bogart who created the original SankeyMATIC tool that this project is based on. It‚Äôs an excellent tool and may even suit your needs better than Budgeteer for simple use cases. Problems with SankeyMATICHowever, what I didn‚Äôt like about SankeyMATIC (and other tools like it) is that modelling flows is a bit inflexible. For example, consider the following: The code to generate this diagram with SankeyMATIC is simple: 123Income [10] RentIncome [10] SavingsIncome [10] Spending However, this code doesn‚Äôt capture the logic of these flows; it only describes results. What would be much better is something like this: 1234Income = supply(30)Rent.consumes(10).from(Income)Income.supplies(10).to(Savings)Income.suppliesRemaining().to(Spending) There‚Äôs a much different intent communicated here: It emphasizes that ‚ÄúIncome‚Äù is a fixed supply with a specific amount It describes ‚ÄúRent‚Äù as ‚Äúconsuming‚Äù income as opposed to ‚Äúbeing supplied by‚Äù income It suggests that ‚ÄúSpending‚Äù is lower priority than rent and savings as it just gets ‚Äúthe leftovers‚Äù This ‚Äúleftovers‚Äù feature would be very nice for making complicated flows. Calculating differences is easy for trivial flows like this, but it becomes unwieldy with more complicated flows like the one shown at the top of this post. Enter BudgeteerIn a nutshell, this more expressive syntax and auto-calculated differences is what Budgeteer provides. Budgeteer does not replace SankeyMATIC, but rather builds directly on top of it; it acts as a middleman, translating a more expressive JavaScript-based API into the code that SankeyMATIC understands. Technically, Budgeteer is a separate, standalone TypeScript package that can operate outside of SankeyMATIC, but it can only be used programmatically. Budgeteer + SankeyMATIC is the website that integrates it into a graphical tool like SankeyMATIC. See the repository for the website if you want to learn more. With that lengthy intro out of the way, let‚Äôs jump into using the Budgeteer Website! Using the Budgeteer WebsiteIf you know how to use SankeyMATIC, you already know most of Budgeteer. The only substantial change is how your code translates into a diagram, which is what I‚Äôll focus on. Budgeteer‚Äôs LanguageBudgeteer understands JavaScript, which is great if you already know JavaScript, but not so great if you don‚Äôt. To mitigate this, I designed the API to read like spoken English as much as possible. Additionally the code editor on the website will help you out a lot as you type: Main ConceptsBudgeteer has just a few main concepts. Understanding them before making a diagram is helpful, but if you‚Äôd rather learn by example, skip to the examples section. NodesEach point where flows connect on the chart is a ‚Äúnode.‚Äù There are three types of nodes: Supplies - Nodes with a fixed supply that only give resources to other nodes Consumers - Nodes that only consume from other nodes Pipes - Nodes that both consume from and supply other nodes Nodes that can consume from other nodes (and thus receive supply) are called supplyable. Nodes that can supply other nodes (and thus be consumed) are called consumable. This means (somewhat confusingly) that supply nodes are consumable, consumer nodes are supplyable, and pipe nodes are both consumable and supplyable. Knowing this terminology isn‚Äôt required for using the tool, but may be helpful if you start digging into the technical side of the API. Node RelationshipsThere are three types of relationships a node can establish with another: A.supplies(&lt;amount&gt;).to(B) or B.consumes(&lt;amount&gt;).from(A) One node supplies a fixed amount to another. A.suppliesAsMuchAsNecessary().to(B) or B.consumesAsMuchAsNecessary().from(A) One node supplies only as much as the other needs. A.suppliesAsMuchAsPossible().to(B) or B.consumesAsMuchAsPossible().from(A) One node gives whatever it can to the other. ExamplesThe default example code on the Budgeteer Website pretty much includes all of budgeteer‚Äôs features. Feel free to skip these examples that‚Äôs enough for you to get the gist. Basic Use: Supplies and ConsumersSupplies and consumers are the basic building blocks of any model in budgeteer. Here‚Äôs an example: 1234let snackMoney = supply('Snack Money', 3.00);consumer('Chips').consumes(1.50).from(snackMoney);consumer('Gatorade').consumes(1.50).from(snackMoney); If you prefer to think of snack money as a supply rather than an object of consumption, you could also write it this way, which results in the exact same diagram: 123supply('Snack Money', 3.00) .supplies(1.50).to(consumer('Chips')) .supplies(1.50).to(consumer('Gatorade')); Variable Supply and ConsumptionYou may encounter some situations where you‚Äôd rather leave a value unspecified. Here‚Äôs an example of how you might do that: 12345678let time = supply('Hours of the day', 24);consumer('Sleep').consumes(8).from(time);consumer('Morning Routine').consumes(1).from(time);consumer('Commute').consumes(0.5).from(time);consumer('Work').consumes(8).from(time);time.suppliesAsMuchAsPossible().to(consumer('Free time')); Notice how ‚ÄúFree time‚Äù is not supplied with a specific amount but rather with ‚Äúas much as possible,‚Äù which happens to be 6.5 in this case. Now suppose you decide to start biking to work which takes twice as long. That brings your commute up to an hour and your free time down to 6. Rather than update both values, you can just update the one that changed (your commute), and the free time will automatically adjust. Using PipesSome models require going beyond basic supplies and consumers, which is where pipes come in. Pipes are useful for pooling or grouping resources: 123456789let combinedIncome = pipe('Combined Income');supply('My Income', 2000).suppliesAsMuchAsPossible().to(combinedIncome);supply('Spouse Income', 2000).suppliesAsMuchAsPossible().to(combinedIncome);consumer('Rent').consumes(1500).from(combinedIncome);consumer('Food').consumes(500).from(combinedIncome);consumer('Other bills').consumes(1200).from(combinedIncome);consumer('Savings').consumesAsMuchAsPossible().from(combinedIncome); Pipes are especially useful with the asMuchAsNecessary relationship. Here‚Äôs a more complex, but practical example: 123456789101112131415161718192021222324252627282930313233const SALARY = 80_000;const WORKERS_PER_DEPARTMENT = 50;const DEPARTMENT_SALARIES = SALARY * WORKERS_PER_DEPARTMENT;let revenue = supply('Company Revenue', 25_000_000);let expenses = pipe('Total Expenses');let profit = consumer('Total Profit');revenue .suppliesAsMuchAsNecessary().to(expenses) .suppliesAsMuchAsPossible().to(profit);expenses .suppliesAsMuchAsNecessary().to(makeDepartment('A')) .suppliesAsMuchAsNecessary().to(makeDepartment('B')) .suppliesAsMuchAsNecessary().to(makeDepartment('C'));// since this is just JavaScript, you can use functions to speed things up!function makeDepartment(name) &#123; let department = pipe(`Department $&#123;name&#125;`); let departmentExpenses = pipe(`Dpt. $&#123;name&#125; Expenses`); department .supplies(DEPARTMENT_SALARIES).to(consumer(`Dpt. $&#123;name&#125; Salaries`)) .suppliesAsMuchAsNecessary().to(departmentExpenses); departmentExpenses .supplies(1_000_000).to(consumer(`Dpt. $&#123;name&#125; Expense 1`)) .supplies(1_000_000).to(consumer(`Dpt. $&#123;name&#125; Expense 2`)) .supplies(1_000_000).to(consumer(`Dpt. $&#123;name&#125; Expense 3`)); return department;&#125; Notice how neither the company‚Äôs total expenses or profit, nor the departments‚Äô total expenses are specified ‚Äì instead, Budgeteer figures out what the values should be behind the scenes. This is by far the most useful addition that Budgeteer brings to SankeyMATIC. Complete API ReferenceThat‚Äôs enough examples for now. This article is meant to provide a basic overview of the Budgeteer API. If you would like a more complete, technical reference, check out the budgeteer repository. Exporting Your ChartThe original SankeyMATIC tool had both PNG and SVG export options. Unfortunately, PNG rendering didn‚Äôt seem to work on my copy of the code and frankly, it wasn‚Äôt worth it for me to figure it out. So you‚Äôll have to use SVG, but hey, SVG is better anyway. * * * Appreciating the Underlying Math MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$', '$'] ] } }); .MathJax_CHTML { font-size: 1.6em; } Trying to figure out the math of balancing these flow networks is what originally plunged me into this project. The problem is deceivingly simple, which is why I originally thought I could just hack up some JavaScript to spit out the SankeyMATIC code for my personal use. However, after several evenings after work spent on trying to develop a good algorithm, I realized it was a trickier problem than I had realized, so I decided to take a different approach. In college, I was briefly acquainted with constraint solvers. If you aren‚Äôt familiar with constraint solvers, they essentially just take a bunch of variables and constraints, and produce a set of values for the variables that satisfy the constraints. After wrestling with the flow balancing problem for awhile, it became clear that a constraint solver (kiwi.js in my case) would be a good tool for the job. But the whole reason I went down this rabbit hole was to develop an alternative to SankeyMATIC‚Äôs rigid and cumbersome language. Just using a constraint solver wasn‚Äôt the answer, because specifying variables and constraints is way more cumbersome and difficult to read. So instead, Budgeteer acts as a translator: This highlighted section above is where all the interesting stuff happens, so that‚Äôs what I‚Äôll be talking about. DefinitionsIn constraint-solving land, everything is a variable. This means that the amount of resources at each node gets its own variable, and the amounts transferred between it and every other node all get their own variables too‚Ä¶ That‚Äôs a lotta variables. To keep things straight, let‚Äôs setup some definitions: Symbol Definition $B_i$ The numeric balance at node $i$ $T^i_j$ The numeric amount transferred from node $i$ to node $j$ $C_i$ The set of nodes that consume from node $i$ $S_i$ The set of nodes that give supply to node $i$ Visual DefinitionsIf you prefer to think visually, this may help you: $$ \\require{AMScd} \\begin{CD} a @>{T^a_b}>> b\\\\ @V{T^a_c}VV @VV{T^b_d}V\\\\ c @>>{T^c_d}> d \\end{CD} $$ Given the previous information, the following statements would also be true: $$ S_a = \\emptyset, C_a = \\{b, c\\}\\\\ S_b = \\{a\\}, C_b = \\{d\\}\\\\ S_c = \\{a\\}, C_c = \\{d\\}\\\\ S_d = \\{b, c\\}, C_d = \\emptyset $$ Turning Flows into ConstraintsWith definitions out of the way, we can start to reason about how budgeteer code will translate to constraints. For example, what does it mean to define a supply node, or a consumer, or a pipe with constraints? Let‚Äôs start with supplies: Creating Supplies12let x = 1000;let s = supply('Supply', x); In the context of balancing budgets we want to make sure that our supply is not overdrawn, so our constraints will look like the following: $$B_s \\geq 0, B_s = x - \\sum_{i \\in C_s} T^s_i$$ This defines the balance for the supply, $s$, to be the initial amount, $x$, minus the sum of transfers to each node that consumes from the supply, additionally stipulating that it not dip below 0. In other words, what the supply has left is what it started with minus the amount that the other nodes took from it. Creating Consumers1let c = consumer('Consumer'); The balance for a consumer is simply the sum of transfers coming in from its suppliers: $$B_c = \\sum_{i \\in S_c} T^i_c$$ Creating Pipes1let p = pipe('Pipe'); Pipes have both suppliers and consumers. In the context of balancing flows, we want the inputs and outputs to cancel out, which means we want the balance to be 0: $$B_p = 0, B_p = (\\sum_{i \\in S_p} T^i_p) - (\\sum_{i \\in C_p} T^p_i)$$ This defines the balance for the pipe, $p$, to be the sum of transfers from each node that supplies it, minus the sum of transfers to each node that consumes from it, which should cancel out to 0. In other words, the pipe should be given the same amount from its suppliers that it gives away to its consumers. Transferring a Fixed Amount12345let s = supply('Supply', 1000);let c = consumer('Consumer');let x = 500;c.consumes(x).from(s); With those constraints specified upfront, establishing relationships is actually pretty straightforward. $$s \\in S_c, c \\in C_s, T^s_c = x, T^s_c = -T^c_s$$ Here we are just saying that $s$ is a supplier of $c$, $c$ is a consumer of $s$, and that the amount transferred between them is $x$. Transferring a Variable Amount123456let s = supply('Supply', 1000);let p = pipe('Pipe');s.suppliesAsMuchAsPossible().to(p);// ors.suppliesAsMuchAsNecessary().to(p); Transferring a variable amount is nearly identical to transferring a fixed amount: $$s \\in S_p, p \\in C_s, T^s_p \\geq 0, T^s_p = -T^p_s$$ Since we don‚Äôt have a specific value, we just say that the transfer between the two nodes should be larger than 0. However, you may be wondering what the difference between ‚Äúas much as possible‚Äù and ‚Äúas much as necessary‚Äù is then. The answer by using ‚Äúweak constraints.‚Äù So far, all the constraints we considered are absolutely required. If the constraint solver can‚Äôt find a set of variables that satisfies every last constraint, it will throw an error. However, you can also specify constraints that the solver will try its best to satisfy, but if it falls short it won‚Äôt throw an error. With this in mind, we can specify an additional ‚Äúweak constraint‚Äù for the suppliesAsMuchAsPossible relationship: $$T^p_s = \\infty$$ Obviously, this can‚Äôt be satisfied, but it will cause the constraint solver to make $T^p_s$ as large as it possibly can without breaking the other constraints. Likewise, we can specify the following weak constraint for the suppliesAsMuchAsNecessary relationship: $$T^p_s = 0$$ Again, this can‚Äôt be satisfied, but it will cause the constraint solver to make $T^p_s$ as small as possible. SummaryThat‚Äôs all of the math! Here‚Äôs a summary of how the various pieces translate: Budgeteer code Required constraints Weak Constraints s = supply(..., x) $B_s \\geq 0, B_s = x - \\sum_{i \\in C_s} T^s_i$ N/A c = consumer(...) $B_c = \\sum_{i \\in S_c} T^i_c$ N/A p = pipe(...) $B_p = 0, B_p = (\\sum_{i \\in S_p} T^i_p) - (\\sum_{i \\in C_p} T^p_i)$ N/A c.consumes(x).from(s) $s \\in S_c, c \\in C_s, T^s_c = x, T^s_c = -T^c_s$ N/A p.consumesAsMuchAsPossible().from(s) $s \\in S_p, p \\in C_s, T^s_p \\geq 0, T^s_p = -T^p_s$ $T^p_s = \\infty$ p.consumesAsMuchAsNecessary().from(s) (same as above) $T^p_s = 0$","link":"/2019/06/25/Budgeteer-A-Budget-Balancing-Tool/"},{"title":"Node.js Terminal Styling Packages Compared","text":"There are many packages for filling your Node.js terminal programs with pretty colors. chalk is by far the most popular, but it may be too heavy for simple use cases. You may find some of these alternatives to be useful: Comparison Package Size Popularity Dependents var packages = [ 'kleur', 'colors-cli', 'colors', 'ansi-styles', 'chalk', 'cli-color', ]; var links = [ function(pkg){ return '' + pkg + ''; }, function(pkg){ return ''; }, function(pkg){ return ''; }, function(pkg){ return ''; } ]; var tbody = document.querySelector('#comparison'); function makeRow(package) { var row = ''; for(var cell of links) { row += '' + cell(package) + '' } row += ''; tbody.innerHTML += row; } packages.forEach(makeRow);","link":"/2019/07/28/Node-js-Terminal-Styling-Packages-Compared/"},{"title":"How I Made a Custom Controller With An Arduino","text":"I recently built a custom arduino-powered controller. It was a lot of fun and easier than I thought it might be. If you‚Äôre thinking of a similar project for yourself, perhaps this post will help or inspire you! MotivationI got new music notation software that makes it easy to input notes from my digital piano, but controlling note duration is a bit clunky because I constantly have to switch between the piano keyboard and the computer keyboard. This got me thinking if there was any way I could make this process smoother. A custom controller perhaps? I‚Äôve had an Arduino Uno sitting around for quite awhile, but I had never done much with it. I‚Äôve also accumulated various mechanical switches over the years, telling myself they‚Äôd eventually be used for some project. What better project than a custom controller! PlanningThe first thing I did was take inventory of the switches I had and which ones I wanted to use. I selected a 12-position switch, a few toggle buttons, and a flip switch (which I decided to add later). One thing I had to sort out was how to deal with all the leads on the 12-position switch. Arduinos have a limited number of input pins, and I didn‚Äôt want to burn them all up on one switch. Since the switch can only be in one position at a time, I realized that the Arduino would only need to know which direction the knob is being turned, and it could figure out the specific position based on how many left/right turns it detects. Here‚Äôs what I came up with, which reduces the 12 leads down to 3: SolderingThis reduction left me plenty of Arduino inputs for more switches. So with that I started cutting/stripping/soldering wire segments to the switch: Just as a sanity check, I made sure to test that my switch was working as expected at each intermediate step. Using my Arduino and some LEDs, I wrote a quick program to display the current value of the switch in binary. (This was before I discovered the Arduino serial monitor, which would have been much easier!): The EnclosureNext, I needed some kind of box to mount all my switches into. I didn‚Äôt have many options in my small apartment, but I happened to have a plastic box from a toy gyroscope sitting around: Breaking the SwitchAs you can see from the pictures above, everything was going smoothly‚Ä¶ until I broke the 12-position while trying to shove the knob on: At first I thought I had just destroyed all my progress, after having spent hours planning/cutting/stripping/soldering/drilling. But it turned out that the switch was mostly OK, it just needed to be put back together. Easier said than done however! Some of these pieces were seriously tiny ‚Äì and worse ‚Äì spring-loaded: This spring and two bearings are what kept the switch ‚Äúsnapped‚Äù into each position. I couldn‚Äôt get take a picture of the inner workings of the spring mechanism, but here‚Äôs a diagram that should give you a rough idea of how it worked: Due to it‚Äôs design, the switch was very challenging to put together. It took two full hours of wrestling with tiny spring-loaded bearings (and chasing after them when they launched out) to finally fix it: Arduino NanoWhile I was working on all this I had ordered an Arduino Nano (or a cheap knockoff rather) to act as the brains of the controller. It was much smaller than my Arduino Uno, but had the same number of pins and programming interface. At this point I realized I had made another oopsie. The new Arduino worked fine, but I realized that I was supposed to get the ‚ÄúArduino Micro‚Äù, not the nano. The relevant difference is that the micro can be recognized by any computer as a HID (Human Interface Device), no drivers required. I originally planned for the controller to just emit keyboard signals, but that wasn‚Äôt a possibility anymore. My only other option besides ordering the proper chip was to write a program that runs on the computer, listens for signals from the Arduino‚Äôs serial port, and fire the appropriate keyboard signals. I opted for the second option, which I‚Äôll talk about more later. Putting it All TogetherHaving decided to keep the nano, I drilled a hole for it in the box: Next, I finished soldering wires to the remaining switches, and hot-glued the arduino in place: I purposely ordered an Arduino with pin headers so I wouldn‚Äôt have to solder any wires directly onto the chip. Plus, it would make it easy to swap in a new one if the chip ever crapped out on me, since I was taking a chance on a knockoff brand. This made the final assembly very easy and less nerve-wracking: Final ProductThat‚Äôs it for hardware! Here‚Äôs a view of the finished product: As mentioned, I had to futz around more on the software side to make it usable with my computer. I chose to write the program in Node.js since that‚Äôs what I‚Äôm familiar with, and luckily there were already two nice modules for listening to the serial port and for simulating keyboard events, which did most of the heavy lifting for me. Without too much work, I built a program that could listen to the controller: From there, it was quick to translate these signals into specific keyboard shortcuts that my music notation software would recognize: Works like a charm! ConclusionOverall, I‚Äôm very happy with the result. Although having to launch a client program for the controller to be recognized is not as convenient as simply plugging in the device, it has the upside of being easier to reprogram, since Node.js is more flexible than C, which is what the Arduino is programmed with. If you‚Äôre considering an Arduino project but lack electrical experience (like me), something like this is a great place to start. Other than when I was testing with LEDs, I didn‚Äôt even need a single resistor for this project ‚Äì it‚Äôs all just wiring and programming. It was a fun project and I learned a lot. Hopefully you learned something too!","link":"/2019/10/09/How-I-Made-a-Custom-Controller-With-Arduino/"}],"tags":[{"name":"miscellaneous","slug":"miscellaneous","link":"/tags/miscellaneous/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"budgeteer","slug":"budgeteer","link":"/tags/budgeteer/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"arduino","slug":"arduino","link":"/tags/arduino/"},{"name":"diy","slug":"diy","link":"/tags/diy/"}],"categories":[]}